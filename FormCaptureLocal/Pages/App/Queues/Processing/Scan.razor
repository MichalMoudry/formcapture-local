@layout AppLayout
@inject NavigationManager NavigationManager
@inject IStringLocalizer<App> Localizer
@inject DataAccess DataAccess
@inject IJSRuntime IJSRuntime
@page "/formcapture/queues/{queueID}/scan"

<div class="jumbotron">
    <h4 class="display-4"><span class="fluentUiGlyph">&#xEA01;</span>  @Localizer["ScanNoun"]</h4>
    <p class="lead">This is a simple hero unit, a simple jumbotron-style component for calling extra attention to featured content or information.</p>
    <hr class="my-4">
    <p>It uses utility classes for typography and spacing to space content out within the larger container.</p>
    @if (queue != null)
    {
        @if (queue.IsAutomatic)
        {

        }
        else
        {
            <a class="btn btn-outline-primary btn-lg" href="#" role="button">Launch scan task</a>
        }
    }
    else
    {
        <h4>@Localizer["Loading"]...</h4>
    }
</div>

<div id="fullPageLoadingScreen" class="@FullPageLoadingScreenCssClass">
    <div class="d-flex justify-content-center main-loading-div">
        Loading...
        <div class="spinner-border mt-4" role="status">
            <span class="sr-only">Loading...</span>
        </div>
    </div>
</div>

@code
{
    /// <summary>
    /// ID of a queue that is going to be processed.
    /// </summary>
    [Parameter]
    public string QueueID { get; set; }

    /// <summary>
    /// Queue that is being processed.
    /// </summary>
    private Queue queue;

    /// <summary>
    /// List of processed files (see: <see cref="ProcessedFile"/> class).
    /// </summary>
    private List<ProcessedFile> processedFiles;

    /// <summary>
    /// List of workflow tasks made by the user for scan portion of document processing.
    /// </summary>
    private List<WorkflowTask> customTasks = new List<WorkflowTask>();

    /// <summary>
    /// Private field indicating if full page loading screen is displayed.
    /// </summary>
    private bool isFullPageLoadingScreenDisplayed;

    /// <summary>
    /// Private filed for seting and geting value of a CSS class for displaying/hiding fullpage loading screen.
    /// </summary>
    private string FullPageLoadingScreenCssClass => isFullPageLoadingScreenDisplayed ? "d-block" : "d-none";

    /// <summary>
    /// Method for processing files. Currently includes only conversion of content to black and white.
    /// </summary>
    private async Task ProcessFiles()
    {
        string unparsedBlackAndWhiteContent;
        var newProcessedFiles = new List<ProcessedFile>();
        foreach (var file in processedFiles)
        {
            //Console.WriteLine($"data:{file.ContentType};base64,{Convert.ToBase64String(file.Content)}");
            unparsedBlackAndWhiteContent = await IJSRuntime.InvokeAsync<string>("convertImageToGreyScale", $"data:{file.ContentType};base64,{Convert.ToBase64String(file.Content)}");
            newProcessedFiles.Add(file);
            //file.BlackAndWhiteContent = Convert.FromBase64String();
        }
        processedFiles = newProcessedFiles;
    }

    /// <summary>
    /// Method for executing custom tasks written in JS.
    /// </summary>
    private async Task ExecuteCustomTasks()
    {
        //If there are custom tasks => execute them
        if (customTasks.Count > 0)
        {
            //Execute each custom task
            foreach (var task in customTasks)
            {
                _ = await IJSRuntime.InvokeAsync<bool>("executeJS", task.Content);
            }
        }
    }

    /// <summary>
    /// Override of OnInitializedAsync() component method.
    /// </summary>
    protected override async Task OnInitializedAsync()
    {
        isFullPageLoadingScreenDisplayed = true;
        try
        {
            queue = await DataAccess.GetItem<Queue>(QueueID, ObjectStores.Queues.ToString());
        }
        catch (Exception)
        {
            NavigationManager.NavigateTo("/NotFound");
            return;
        }
        if (queue != null)
        {
            //Get processed files
            processedFiles = await DataAccess.GetItemsAsList<ProcessedFile>(ObjectStores.ProcessedFiles.ToString());
            if (processedFiles != null)
            {
                processedFiles = processedFiles.Where(i => i.QueueID.Equals(QueueID)).ToList();
                //If workflow id is set retrieve groupings and potential tasks
                if (!string.IsNullOrEmpty(queue.WorkflowID))
                {
                    //Get workflow-task groupings
                    var workflowTaskGroupings = await DataAccess.GetItemsAsList<WorkflowTaskGrouping>(ObjectStores.WorkflowTaskGroupings.ToString());
                    //Filter workflow-task groupings that are not part of selected workflow and are not for scan
                    workflowTaskGroupings = workflowTaskGroupings
                        .Where(i => i.WorkflowID.Equals(queue.WorkflowID) && i.TaskGroupName.Equals($"{QueueTask.Scan}"))
                        .OrderBy(i => i.ExecutionOrderNumber)
                        .ToList();
                    //Workflow does not need to have any tasks => check needed
                    if (workflowTaskGroupings.Count > 0)
                    {
                        //Get all tasks
                        var allTasks = await DataAccess.GetItemsAsList<WorkflowTask>(ObjectStores.WorkflowTasks.ToString());
                        foreach (var grouping in workflowTaskGroupings)
                        {
                            //Add task that corresponds with TaskID in the grouping
                            customTasks.Add(allTasks.Single(i => i.ID.Equals(grouping.TaskID)));
                        }
                    }
                }
                if (queue.IsAutomatic)
                {
                    //Process files
                    await ProcessFiles();
                    //Execute tasks
                    await ExecuteCustomTasks();
                }
            }
        }
        isFullPageLoadingScreenDisplayed = false;
    }
}